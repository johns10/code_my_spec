{
  "commands": [
    {
      "args": [
        "dialyzer",
        "--format",
        "short",
        "--quiet"
      ],
      "command": "mix",
      "exit_code": 0,
      "opts": {
        "cd": "../code_my_spec_test_repos/dialyzer_test_7810",
        "env": {
          "MIX_ENV": "test"
        },
        "stderr_to_stdout": true
      },
      "output": "==> file_system\nCompiling 7 files (.ex)\nGenerated file_system app\n==> mime\nCompiling 1 file (.ex)\nGenerated mime app\n==> nimble_options\nCompiling 3 files (.ex)\nGenerated nimble_options app\n==> fine\nCompiling 1 file (.ex)\nGenerated fine app\n==> bunt\nCompiling 2 files (.ex)\nGenerated bunt app\n==> comeonin\nCompiling 3 files (.ex)\nGenerated comeonin app\n==> plug_crypto\nCompiling 5 files (.ex)\nGenerated plug_crypto app\n==> hpax\nCompiling 4 files (.ex)\nGenerated hpax app\n==> mint\nCompiling 1 file (.erl)\nCompiling 20 files (.ex)\nGenerated mint app\n==> erlex\nCompiling 2 files (.erl)\nCompiling 1 file (.ex)\nGenerated erlex app\n==> elixir_make\nCompiling 8 files (.ex)\nGenerated elixir_make app\n==> bcrypt_elixir\nmkdir -p \"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_7810/_build/test/lib/bcrypt_elixir/priv\"\ncc -g -O3 -Wall -Wno-format-truncation -I\"/Users/johndavenport/.asdf/installs/erlang/28.1/erts-16.1/include\" -Ic_src -fPIC -shared -dynamiclib -undefined dynamic_lookup c_src/bcrypt_nif.c c_src/blowfish.c -o \"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_7810/_build/test/lib/bcrypt_elixir/priv/bcrypt_nif.so\"\nCompiling 3 files (.ex)\nGenerated bcrypt_elixir app\n==> decimal\nCompiling 4 files (.ex)\nGenerated decimal app\n==> jason\nCompiling 10 files (.ex)\nGenerated jason app\n==> esbuild\nCompiling 4 files (.ex)\nGenerated esbuild app\n==> mix_machine\nCompiling 6 files (.ex)\nGenerated mix_machine app\n==> sobelow\nCompiling 51 files (.ex)\nGenerated sobelow app\n==> poison\nCompiling 4 files (.ex)\nGenerated poison app\n==> exunit_json_formatter\nCompiling 1 file (.ex)\nGenerated exunit_json_formatter app\n==> test_phoenix_project\n===> Analyzing applications...\n===> Compiling telemetry\n==> telemetry_metrics\nCompiling 7 files (.ex)\nGenerated telemetry_metrics app\n==> test_phoenix_project\n===> Analyzing applications...\n===> Compiling telemetry_poller\n==> thousand_island\nCompiling 16 files (.ex)\nGenerated thousand_island app\n==> db_connection\nCompiling 17 files (.ex)\nGenerated db_connection app\n==> ecto\nCompiling 56 files (.ex)\nGenerated ecto app\n==> phoenix_html\nCompiling 6 files (.ex)\nGenerated phoenix_html app\n==> phoenix_template\nCompiling 4 files (.ex)\nGenerated phoenix_template app\n==> expo\nCompiling 2 files (.erl)\nCompiling 22 files (.ex)\n    warning: a struct for Expo.Messages is expected on struct update:\n\n        %Expo.Messages{po | file: Keyword.get(opts, :file)}\n\n    but got type:\n\n        dynamic()\n\n    where \"po\" was given the type:\n\n        # type: dynamic()\n        # from: lib/expo/po/parser.ex:17:20\n        {:ok, po} <- check_for_duplicates(po)\n\n    when defining the variable \"po\", you must also pattern match on \"%Expo.Messages{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 18 │       {:ok, %Messages{po | file: Keyword.get(opts, :file)}}\n    │             ~\n    │\n    └─ lib/expo/po/parser.ex:18:13: Expo.PO.Parser.parse/2\n\n     warning: a struct for Expo.Messages is expected on struct update:\n\n         %Expo.Messages{po | file: path}\n\n     but got type:\n\n         dynamic()\n\n     where \"po\" was given the type:\n\n         # type: dynamic()\n         # from: lib/expo/mo.ex:132:20\n         {:ok, po} <- Expo.MO.Parser.parse(contents, Keyword.put_new(options, :file, path))\n\n     when defining the variable \"po\", you must also pattern match on \"%Expo.Messages{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 133 │       {:ok, %Messages{po | file: path}}\n     │             ~\n     │\n     └─ lib/expo/mo.ex:133:13: Expo.MO.parse_file/2\n\nGenerated expo app\n==> gettext\nCompiling 18 files (.ex)\nGenerated gettext app\n==> phoenix_pubsub\nCompiling 11 files (.ex)\n    warning: a struct for Phoenix.Tracker.Replica is expected on struct update:\n\n        %Phoenix.Tracker.Replica{replica | status: :permdown}\n\n    but got type:\n\n        dynamic()\n\n    where \"replica\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/replica.ex:72:17\n        replica\n\n    when defining the variable \"replica\", you must also pattern match on \"%Phoenix.Tracker.Replica{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 72 │   defp permdown(replica), do: %Replica{replica | status: :permdown}\n    │                               ~\n    │\n    └─ lib/phoenix/tracker/replica.ex:72:31: Phoenix.Tracker.Replica.permdown/1\n\n    warning: a struct for Phoenix.Tracker.Replica is expected on struct update:\n\n        %Phoenix.Tracker.Replica{replica | status: :down}\n\n    but got type:\n\n        dynamic()\n\n    where \"replica\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/replica.ex:74:13\n        replica\n\n    when defining the variable \"replica\", you must also pattern match on \"%Phoenix.Tracker.Replica{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 74 │   defp down(replica), do: %Replica{replica | status: :down}\n    │                           ~\n    │\n    └─ lib/phoenix/tracker/replica.ex:74:27: Phoenix.Tracker.Replica.down/1\n\n    warning: a struct for Phoenix.Tracker.Replica is expected on struct update:\n\n        %Phoenix.Tracker.Replica{replica | last_heartbeat_at: now_ms()}\n\n    but got type:\n\n        dynamic()\n\n    where \"replica\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/replica.ex:76:29\n        replica\n\n    when defining the variable \"replica\", you must also pattern match on \"%Phoenix.Tracker.Replica{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 77 │     %Replica{replica | last_heartbeat_at: now_ms()}\n    │     ~\n    │\n    └─ lib/phoenix/tracker/replica.ex:77:5: Phoenix.Tracker.Replica.touch_last_heartbeat/1\n\n    warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n        %Phoenix.Tracker.State{state | clouds: pruned_clouds, delta: new_delta}\n\n    but got type:\n\n        dynamic()\n\n    where \"state\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/state.ex:92:18\n        state\n\n    when defining the variable \"state\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 97 │     state = bump_clock(%State{state | clouds: pruned_clouds, delta: new_delta})\n    │                        ~\n    │\n    └─ lib/phoenix/tracker/state.ex:97:24: Phoenix.Tracker.State.leave_join/5\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{local | clouds: clouds, delta: delta}\n\n     but got type:\n\n         dynamic()\n\n     where \"local\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:310:14\n         local\n\n     when defining the variable \"local\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 339 │       %State{local | clouds: clouds, delta: delta}\n     │       ~\n     │\n     └─ lib/phoenix/tracker/state.ex:339:7: Phoenix.Tracker.State.merge/3\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{delta | values: Map.put(delta.values, tag, {pid, topic, key, meta})}\n\n     but got type:\n\n         dynamic()\n\n     where \"delta\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:506:36\n         %Phoenix.Tracker.State{delta: delta} = state\n\n     when defining the variable \"delta\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 510 │     new_delta = %State{delta | values: Map.put(delta.values, tag, {pid, topic, key, meta})}\n     │                 ~\n     │\n     └─ lib/phoenix/tracker/state.ex:510:17: Phoenix.Tracker.State.do_add/5\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{delta | clouds: put_tag(delta.clouds, {rep, new_clock})}\n\n     but got type:\n\n         dynamic()\n\n     where \"delta\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:586:99\n         %Phoenix.Tracker.State{mode: :normal, replica: rep, clouds: clouds, context: ctx, delta: delta} =\n           state\n\n     when defining the variable \"delta\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 592 │            delta: %State{delta | clouds: put_tag(delta.clouds, {rep, new_clock})}}\n     │                   ~\n     │\n     └─ lib/phoenix/tracker/state.ex:592:19: Phoenix.Tracker.State.bump_clock/1\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{delta | range: {start_clock, new_end}}\n\n     but got type:\n\n         dynamic()\n\n     where \"delta\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:595:55\n         %Phoenix.Tracker.State{delta: delta, replica: rep} = state\n\n     when defining the variable \"delta\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 600 │            delta: %State{delta | range: {start_clock, new_end}}}\n     │                   ~\n     │\n     └─ lib/phoenix/tracker/state.ex:600:19: Phoenix.Tracker.State.put_context/2\n\nGenerated phoenix_pubsub app\n==> dns_cluster\nCompiling 1 file (.ex)\nGenerated dns_cluster app\n==> dialyxir\nCompiling 67 files (.ex)\nGenerated dialyxir app\n==> credo\nCompiling 253 files (.ex)\nGenerated credo app\n==> plug\nCompiling 1 file (.erl)\nCompiling 40 files (.ex)\nGenerated plug app\n==> postgrex\nCompiling 69 files (.ex)\nCompiling lib/postgrex/default_types.ex (it's taking more than 10s)\nGenerated postgrex app\n==> phoenix_ecto\nCompiling 7 files (.ex)\nGenerated phoenix_ecto app\n==> ecto_sql\nCompiling 25 files (.ex)\nGenerated ecto_sql app\n==> nimble_pool\nCompiling 2 files (.ex)\nGenerated nimble_pool app\n==> finch\nCompiling 14 files (.ex)\nGenerated finch app\n==> req\nCompiling 19 files (.ex)\nGenerated req app\n==> cc_precompiler\nCompiling 3 files (.ex)\nGenerated cc_precompiler app\n==> lazy_html\nCompiling 3 files (.ex)\nGenerated lazy_html app\n==> tailwind\nCompiling 3 files (.ex)\nGenerated tailwind app\n==> websock\nCompiling 1 file (.ex)\nGenerated websock app\n==> bandit\nCompiling 54 files (.ex)\nGenerated bandit app\n==> swoosh\nCompiling 53 files (.ex)\nGenerated swoosh app\n==> websock_adapter\nCompiling 4 files (.ex)\nGenerated websock_adapter app\n==> phoenix\nCompiling 74 files (.ex)\nGenerated phoenix app\n==> phoenix_live_view\nCompiling 48 files (.ex)\nGenerated phoenix_live_view app\n==> phoenix_live_dashboard\nCompiling 36 files (.ex)\nGenerated phoenix_live_dashboard app\nxmerl_ucs.erl:58:1: Warning: missing specification for function is_iso10646/1\nxmerl_ucs.erl:70:1: Warning: missing specification for function is_unicode/1\nxmerl_ucs.erl:75:1: Warning: missing specification for function is_bmpchar/1\nxmerl_ucs.erl:84:1: Warning: missing specification for function is_latin1/1\nxmerl_ucs.erl:88:1: Warning: missing specification for function is_ascii/1\nxmerl_ucs.erl:92:1: Warning: missing specification for function is_iso646_basic/1\nxmerl_ucs.erl:108:1: Warning: missing specification for function is_visible_latin1/1\nxmerl_ucs.erl:117:1: Warning: missing specification for function is_visible_ascii/1\nxmerl_ucs.erl:122:1: Warning: missing specification for function to_ucs4be/1\nxmerl_ucs.erl:125:1: Warning: missing specification for function from_ucs4be/1\nxmerl_ucs.erl:128:1: Warning: missing specification for function from_ucs4be/2\nxmerl_ucs.erl:131:1: Warning: missing specification for function to_ucs4le/1\nxmerl_ucs.erl:134:1: Warning: missing specification for function from_ucs4le/1\nxmerl_ucs.erl:137:1: Warning: missing specification for function from_ucs4le/2\nxmerl_ucs.erl:141:1: Warning: missing specification for function to_ucs2be/1\nxmerl_ucs.erl:144:1: Warning: missing specification for function from_ucs2be/1\nxmerl_ucs.erl:147:1: Warning: missing specification for function from_ucs2be/2\nxmerl_ucs.erl:150:1: Warning: missing specification for function to_ucs2le/1\nxmerl_ucs.erl:153:1: Warning: missing specification for function from_ucs2le/1\nxmerl_ucs.erl:156:1: Warning: missing specification for function from_ucs2le/2\nxmerl_ucs.erl:161:1: Warning: missing specification for function to_utf16be/1\nxmerl_ucs.erl:164:1: Warning: missing specification for function from_utf16be/1\nxmerl_ucs.erl:167:1: Warning: missing specification for function from_utf16be/2\nxmerl_ucs.erl:170:1: Warning: missing specification for function to_utf16le/1\nxmerl_ucs.erl:173:1: Warning: missing specification for function from_utf16le/1\nxmerl_ucs.erl:176:1: Warning: missing specification for function from_utf16le/2\nxmerl_ucs.erl:181:1: Warning: missing specification for function to_utf8/1\nxmerl_ucs.erl:184:1: Warning: missing specification for function from_utf8/1\nxmerl_ucs.erl:193:1: Warning: missing specification for function from_latin9/1\nxmerl_ucs.erl:483:1: Warning: missing specification for function to_unicode/2\nxmerl_ucs.erl:523:1: Warning: missing specification for function is_incharset/2\n",
      "recorded_at": "2026-01-17T05:06:32.099446Z"
    },
    {
      "args": [
        "dialyzer",
        "--format",
        "short"
      ],
      "command": "mix",
      "exit_code": 0,
      "opts": {
        "cd": "../code_my_spec_test_repos/dialyzer_test_84930",
        "env": {
          "MIX_ENV": "test"
        },
        "stderr_to_stdout": true
      },
      "output": "==> file_system\nCompiling 7 files (.ex)\nGenerated file_system app\n==> mime\nCompiling 1 file (.ex)\nGenerated mime app\n==> nimble_options\nCompiling 3 files (.ex)\nGenerated nimble_options app\n==> fine\nCompiling 1 file (.ex)\nGenerated fine app\n==> bunt\nCompiling 2 files (.ex)\nGenerated bunt app\n==> comeonin\nCompiling 3 files (.ex)\nGenerated comeonin app\n==> plug_crypto\nCompiling 5 files (.ex)\nGenerated plug_crypto app\n==> hpax\nCompiling 4 files (.ex)\nGenerated hpax app\n==> mint\nCompiling 1 file (.erl)\nCompiling 20 files (.ex)\nGenerated mint app\n==> erlex\nCompiling 2 files (.erl)\nCompiling 1 file (.ex)\nGenerated erlex app\n==> elixir_make\nCompiling 8 files (.ex)\nGenerated elixir_make app\n==> bcrypt_elixir\nmkdir -p \"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/bcrypt_elixir/priv\"\ncc -g -O3 -Wall -Wno-format-truncation -I\"/Users/johndavenport/.asdf/installs/erlang/28.1/erts-16.1/include\" -Ic_src -fPIC -shared -dynamiclib -undefined dynamic_lookup c_src/bcrypt_nif.c c_src/blowfish.c -o \"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/bcrypt_elixir/priv/bcrypt_nif.so\"\nCompiling 3 files (.ex)\nGenerated bcrypt_elixir app\n==> decimal\nCompiling 4 files (.ex)\nGenerated decimal app\n==> jason\nCompiling 10 files (.ex)\nGenerated jason app\n==> esbuild\nCompiling 4 files (.ex)\nGenerated esbuild app\n==> mix_machine\nCompiling 6 files (.ex)\nGenerated mix_machine app\n==> sobelow\nCompiling 51 files (.ex)\nGenerated sobelow app\n==> poison\nCompiling 4 files (.ex)\nGenerated poison app\n==> exunit_json_formatter\nCompiling 1 file (.ex)\nGenerated exunit_json_formatter app\n==> test_phoenix_project\n===> Analyzing applications...\n===> Compiling telemetry\n==> telemetry_metrics\nCompiling 7 files (.ex)\nGenerated telemetry_metrics app\n==> test_phoenix_project\n===> Analyzing applications...\n===> Compiling telemetry_poller\n==> thousand_island\nCompiling 16 files (.ex)\nGenerated thousand_island app\n==> db_connection\nCompiling 17 files (.ex)\nGenerated db_connection app\n==> ecto\nCompiling 56 files (.ex)\nGenerated ecto app\n==> phoenix_html\nCompiling 6 files (.ex)\nGenerated phoenix_html app\n==> phoenix_template\nCompiling 4 files (.ex)\nGenerated phoenix_template app\n==> expo\nCompiling 2 files (.erl)\nCompiling 22 files (.ex)\n    warning: a struct for Expo.Messages is expected on struct update:\n\n        %Expo.Messages{po | file: Keyword.get(opts, :file)}\n\n    but got type:\n\n        dynamic()\n\n    where \"po\" was given the type:\n\n        # type: dynamic()\n        # from: lib/expo/po/parser.ex:17:20\n        {:ok, po} <- check_for_duplicates(po)\n\n    when defining the variable \"po\", you must also pattern match on \"%Expo.Messages{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 18 │       {:ok, %Messages{po | file: Keyword.get(opts, :file)}}\n    │             ~\n    │\n    └─ lib/expo/po/parser.ex:18:13: Expo.PO.Parser.parse/2\n\n     warning: a struct for Expo.Messages is expected on struct update:\n\n         %Expo.Messages{po | file: path}\n\n     but got type:\n\n         dynamic()\n\n     where \"po\" was given the type:\n\n         # type: dynamic()\n         # from: lib/expo/mo.ex:132:20\n         {:ok, po} <- Expo.MO.Parser.parse(contents, Keyword.put_new(options, :file, path))\n\n     when defining the variable \"po\", you must also pattern match on \"%Expo.Messages{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 133 │       {:ok, %Messages{po | file: path}}\n     │             ~\n     │\n     └─ lib/expo/mo.ex:133:13: Expo.MO.parse_file/2\n\nGenerated expo app\n==> gettext\nCompiling 18 files (.ex)\nGenerated gettext app\n==> phoenix_pubsub\nCompiling 11 files (.ex)\n    warning: a struct for Phoenix.Tracker.Replica is expected on struct update:\n\n        %Phoenix.Tracker.Replica{replica | status: :permdown}\n\n    but got type:\n\n        dynamic()\n\n    where \"replica\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/replica.ex:72:17\n        replica\n\n    when defining the variable \"replica\", you must also pattern match on \"%Phoenix.Tracker.Replica{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 72 │   defp permdown(replica), do: %Replica{replica | status: :permdown}\n    │                               ~\n    │\n    └─ lib/phoenix/tracker/replica.ex:72:31: Phoenix.Tracker.Replica.permdown/1\n\n    warning: a struct for Phoenix.Tracker.Replica is expected on struct update:\n\n        %Phoenix.Tracker.Replica{replica | status: :down}\n\n    but got type:\n\n        dynamic()\n\n    where \"replica\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/replica.ex:74:13\n        replica\n\n    when defining the variable \"replica\", you must also pattern match on \"%Phoenix.Tracker.Replica{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 74 │   defp down(replica), do: %Replica{replica | status: :down}\n    │                           ~\n    │\n    └─ lib/phoenix/tracker/replica.ex:74:27: Phoenix.Tracker.Replica.down/1\n\n    warning: a struct for Phoenix.Tracker.Replica is expected on struct update:\n\n        %Phoenix.Tracker.Replica{replica | last_heartbeat_at: now_ms()}\n\n    but got type:\n\n        dynamic()\n\n    where \"replica\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/replica.ex:76:29\n        replica\n\n    when defining the variable \"replica\", you must also pattern match on \"%Phoenix.Tracker.Replica{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 77 │     %Replica{replica | last_heartbeat_at: now_ms()}\n    │     ~\n    │\n    └─ lib/phoenix/tracker/replica.ex:77:5: Phoenix.Tracker.Replica.touch_last_heartbeat/1\n\n    warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n        %Phoenix.Tracker.State{state | clouds: pruned_clouds, delta: new_delta}\n\n    but got type:\n\n        dynamic()\n\n    where \"state\" was given the type:\n\n        # type: dynamic()\n        # from: lib/phoenix/tracker/state.ex:92:18\n        state\n\n    when defining the variable \"state\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n    hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n        user = some_function()\n        %User{user | name: \"John Doe\"}\n\n    it is enough to write:\n\n        %User{} = user = some_function()\n        %{user | name: \"John Doe\"}\n\n    typing violation found at:\n    │\n 97 │     state = bump_clock(%State{state | clouds: pruned_clouds, delta: new_delta})\n    │                        ~\n    │\n    └─ lib/phoenix/tracker/state.ex:97:24: Phoenix.Tracker.State.leave_join/5\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{local | clouds: clouds, delta: delta}\n\n     but got type:\n\n         dynamic()\n\n     where \"local\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:310:14\n         local\n\n     when defining the variable \"local\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 339 │       %State{local | clouds: clouds, delta: delta}\n     │       ~\n     │\n     └─ lib/phoenix/tracker/state.ex:339:7: Phoenix.Tracker.State.merge/3\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{delta | values: Map.put(delta.values, tag, {pid, topic, key, meta})}\n\n     but got type:\n\n         dynamic()\n\n     where \"delta\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:506:36\n         %Phoenix.Tracker.State{delta: delta} = state\n\n     when defining the variable \"delta\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 510 │     new_delta = %State{delta | values: Map.put(delta.values, tag, {pid, topic, key, meta})}\n     │                 ~\n     │\n     └─ lib/phoenix/tracker/state.ex:510:17: Phoenix.Tracker.State.do_add/5\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{delta | clouds: put_tag(delta.clouds, {rep, new_clock})}\n\n     but got type:\n\n         dynamic()\n\n     where \"delta\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:586:99\n         %Phoenix.Tracker.State{mode: :normal, replica: rep, clouds: clouds, context: ctx, delta: delta} =\n           state\n\n     when defining the variable \"delta\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 592 │            delta: %State{delta | clouds: put_tag(delta.clouds, {rep, new_clock})}}\n     │                   ~\n     │\n     └─ lib/phoenix/tracker/state.ex:592:19: Phoenix.Tracker.State.bump_clock/1\n\n     warning: a struct for Phoenix.Tracker.State is expected on struct update:\n\n         %Phoenix.Tracker.State{delta | range: {start_clock, new_end}}\n\n     but got type:\n\n         dynamic()\n\n     where \"delta\" was given the type:\n\n         # type: dynamic()\n         # from: lib/phoenix/tracker/state.ex:595:55\n         %Phoenix.Tracker.State{delta: delta, replica: rep} = state\n\n     when defining the variable \"delta\", you must also pattern match on \"%Phoenix.Tracker.State{}\".\n\n     hint: given pattern matching is enough to catch typing errors, you may optionally convert the struct update into a map update. For example, instead of:\n\n         user = some_function()\n         %User{user | name: \"John Doe\"}\n\n     it is enough to write:\n\n         %User{} = user = some_function()\n         %{user | name: \"John Doe\"}\n\n     typing violation found at:\n     │\n 600 │            delta: %State{delta | range: {start_clock, new_end}}}\n     │                   ~\n     │\n     └─ lib/phoenix/tracker/state.ex:600:19: Phoenix.Tracker.State.put_context/2\n\nGenerated phoenix_pubsub app\n==> dns_cluster\nCompiling 1 file (.ex)\nGenerated dns_cluster app\n==> dialyxir\nCompiling 67 files (.ex)\nGenerated dialyxir app\n==> credo\nCompiling 253 files (.ex)\nGenerated credo app\n==> plug\nCompiling 1 file (.erl)\nCompiling 40 files (.ex)\nGenerated plug app\n==> postgrex\nCompiling 69 files (.ex)\nGenerated postgrex app\n==> phoenix_ecto\nCompiling 7 files (.ex)\nGenerated phoenix_ecto app\n==> ecto_sql\nCompiling 25 files (.ex)\nGenerated ecto_sql app\n==> nimble_pool\nCompiling 2 files (.ex)\nGenerated nimble_pool app\n==> finch\nCompiling 14 files (.ex)\nGenerated finch app\n==> req\nCompiling 19 files (.ex)\nGenerated req app\n==> cc_precompiler\nCompiling 3 files (.ex)\nGenerated cc_precompiler app\n==> lazy_html\nCompiling 3 files (.ex)\nGenerated lazy_html app\n==> tailwind\nCompiling 3 files (.ex)\nGenerated tailwind app\n==> websock\nCompiling 1 file (.ex)\nGenerated websock app\n==> bandit\nCompiling 54 files (.ex)\nGenerated bandit app\n==> swoosh\nCompiling 53 files (.ex)\nGenerated swoosh app\n==> websock_adapter\nCompiling 4 files (.ex)\nGenerated websock_adapter app\n==> phoenix\nCompiling 74 files (.ex)\nGenerated phoenix app\n==> phoenix_live_view\nCompiling 48 files (.ex)\nGenerated phoenix_live_view app\n==> phoenix_live_dashboard\nCompiling 36 files (.ex)\nGenerated phoenix_live_dashboard app\n==> test_phoenix_project\nCompiling 35 files (.ex)\nGenerated test_phoenix_project app\nFinding suitable PLTs\nChecking PLT...\n[:asn1, :bandit, :bcrypt_elixir, :bunt, :comeonin, :compiler, :credo, :crypto, :db_connection, :decimal, :dns_cluster, :ecto, :ecto_sql, :eex, :elixir, :elixir_make, :ex_unit, :expo, :exunit_json_formatter, :file_system, :finch, :fine, :gettext, :hpax, :inets, :jason, :kernel, :lazy_html, :logger, :mime, :mint, :mix_machine, :nimble_options, :nimble_pool, :phoenix, :phoenix_ecto, :phoenix_html, :phoenix_live_dashboard, :phoenix_live_view, :phoenix_pubsub, :phoenix_template, :plug, :plug_crypto, :poison, :postgrex, :public_key, :req, :runtime_tools, :sobelow, :ssl, :stdlib, :swoosh, :telemetry, :telemetry_metrics, :telemetry_poller, :test_phoenix_project, :thousand_island, :websock, :websock_adapter, :xmerl]\nLooking up modules in dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nLooking up modules in dialyxir_erlang-28.1_elixir-1.19.4.plt\nFinding applications for dialyxir_erlang-28.1_elixir-1.19.4.plt\nFinding modules for dialyxir_erlang-28.1_elixir-1.19.4.plt\nRemoving 6 modules from dialyxir_erlang-28.1_elixir-1.19.4.plt\nChecking 485 modules in dialyxir_erlang-28.1_elixir-1.19.4.plt\nAdding 6 modules to dialyxir_erlang-28.1_elixir-1.19.4.plt\ndone in 0m29.1s\nFinding applications for dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nFinding modules for dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nCopying dialyxir_erlang-28.1_elixir-1.19.4.plt to dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nLooking up modules in dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nChecking 491 modules in dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nAdding 1638 modules to dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\nxmerl_ucs.erl:58:1: Warning: missing specification for function is_iso10646/1\nxmerl_ucs.erl:70:1: Warning: missing specification for function is_unicode/1\nxmerl_ucs.erl:75:1: Warning: missing specification for function is_bmpchar/1\nxmerl_ucs.erl:84:1: Warning: missing specification for function is_latin1/1\nxmerl_ucs.erl:88:1: Warning: missing specification for function is_ascii/1\nxmerl_ucs.erl:92:1: Warning: missing specification for function is_iso646_basic/1\nxmerl_ucs.erl:108:1: Warning: missing specification for function is_visible_latin1/1\nxmerl_ucs.erl:117:1: Warning: missing specification for function is_visible_ascii/1\nxmerl_ucs.erl:122:1: Warning: missing specification for function to_ucs4be/1\nxmerl_ucs.erl:125:1: Warning: missing specification for function from_ucs4be/1\nxmerl_ucs.erl:128:1: Warning: missing specification for function from_ucs4be/2\nxmerl_ucs.erl:131:1: Warning: missing specification for function to_ucs4le/1\nxmerl_ucs.erl:134:1: Warning: missing specification for function from_ucs4le/1\nxmerl_ucs.erl:137:1: Warning: missing specification for function from_ucs4le/2\nxmerl_ucs.erl:141:1: Warning: missing specification for function to_ucs2be/1\nxmerl_ucs.erl:144:1: Warning: missing specification for function from_ucs2be/1\nxmerl_ucs.erl:147:1: Warning: missing specification for function from_ucs2be/2\nxmerl_ucs.erl:150:1: Warning: missing specification for function to_ucs2le/1\nxmerl_ucs.erl:153:1: Warning: missing specification for function from_ucs2le/1\nxmerl_ucs.erl:156:1: Warning: missing specification for function from_ucs2le/2\nxmerl_ucs.erl:161:1: Warning: missing specification for function to_utf16be/1\nxmerl_ucs.erl:164:1: Warning: missing specification for function from_utf16be/1\nxmerl_ucs.erl:167:1: Warning: missing specification for function from_utf16be/2\nxmerl_ucs.erl:170:1: Warning: missing specification for function to_utf16le/1\nxmerl_ucs.erl:173:1: Warning: missing specification for function from_utf16le/1\nxmerl_ucs.erl:176:1: Warning: missing specification for function from_utf16le/2\nxmerl_ucs.erl:181:1: Warning: missing specification for function to_utf8/1\nxmerl_ucs.erl:184:1: Warning: missing specification for function from_utf8/1\nxmerl_ucs.erl:193:1: Warning: missing specification for function from_latin9/1\nxmerl_ucs.erl:483:1: Warning: missing specification for function to_unicode/2\nxmerl_ucs.erl:523:1: Warning: missing specification for function is_incharset/2\ndone in 1m40.86s\nNo :ignore_warnings opt specified in mix.exs and default does not exist.\n\nStarting Dialyzer\n[\n  check_plt: false,\n  init_plt: ~c\"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/dialyxir_erlang-28.1_elixir-1.19.4_deps-test.plt\",\n  files: [~c\"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/test_phoenix_project/ebin/Elixir.Inspect.TestPhoenixProject.Accounts.User.beam\",\n   ~c\"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/test_phoenix_project/ebin/Elixir.TestPhoenixProject.Accounts.User.beam\",\n   ~c\"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/test_phoenix_project/ebin/Elixir.TestPhoenixProject.BlogFixtures.beam\",\n   ~c\"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/test_phoenix_project/ebin/Elixir.TestPhoenixProject.Blog.Post.beam\",\n   ~c\"/Users/johndavenport/Documents/github/code_my_spec_test_repos/dialyzer_test_84930/_build/test/lib/test_phoenix_project/ebin/Elixir.TestPhoenixProjectWeb.ConnCase.beam\",\n   ...],\n  ...\n]\nTotal errors: 0, Skipped: 0, Unnecessary Skips: 0\ndone in 0m3.06s\ndone (passed successfully)\n",
      "recorded_at": "2026-01-17T05:10:15.682687Z"
    }
  ],
  "ports": []
}